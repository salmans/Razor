Chase.Data.hs:data Problem h s it where
Config.hs:data InputType = GeoLog | TPTPCNF | TPTPFOF
Config.hs:data Config = Config { configInput              :: Maybe String
Explain.hs:data ExplainMode = ExplainM
Explain.hs:data ExplainCommand = Blame Formula | Name Bool Bool Term
Explore.hs:data ExploreMode = ExploreM
Explore.hs:data ExploreCommand = Viz | Current | Next | Push Formula | Pop
FirstOrder.hs:data Atom = Rel   RelSym [Term]
FirstOrder.hs:data Formula = Tru
Geometric.hs:data Atom = Rel   RelSym [Term]
Geometric.hs:data Formula = Tru
Geometric.hs:data Sequent = Sequent {
GeometricUtils.hs:data VarTree = VarTreeLeaf [(Variable, Maybe FnSym)]
Input.hs:data Input = Input { inputTheory         :: Theory
Lang.hs:data TableRef  = ConstTable Constant -- constant tables
Lang.hs:data TupleD a  = Tuple { tupleElems :: Tup 
Lang.hs:data RelExp = TblEmpty
Main.hs:data REPLCommand = Display Substate | ModeHelp | Help | Exit
Main.hs:data Substate = TheConfig | TheTheory | TheModel
Model.hs:data Model = Model { modelElements     :: Map.Map Element [Element]
Model.hs:data QueryResult = QRTable [Variable] [[Element]]
Observation.hs:data Observation = Obs Atom
Observation.hs:data ObservationSequent = ObservationSequent 
PossibleFacts.hs:data RelSequent = 
PossibleFacts.hs:data RelResultSet = RelResultSet 
Provenance.hs:data Blame = TheoryBlame Id Sub | UserBlame Observation
Provenance.hs:data ProvInfo = ProvInfo { elementProvs     :: ElementProvs
SMTLib2.hs:data SMTObservation = SMTFactObs SMTAtom
SMTLib2.hs:data ResKind  = RKBool | RKInteger
SMTLib2.hs:data ResValue = RVBool Bool
SMTLib2.hs:data Result   = Result { resKind  :: ResKind
SMTLib2.hs:data SatResult = Unsatisfiable
SMTLib2.hs:data UninterpretFn =
SMTLib2.hs:data UninterpretRel = UnintRel0 SBool
SMTLib2.hs:data SMTContainer  = SMTContainer 
Surface.hs:data RazorState = RazorState Config (Maybe Theory) ModelSpace (Maybe ModelCoordinate)
Surface.hs:data ModelCoordinate = Stream ModelCoordinate | Stack Observation ModelCoordinate | Origin
Surface.hs:data QOrigin = QOriginLeaf Term QBlame | QOriginNode Term QBlame [QOrigin]
Term.hs:data Term = Var  Variable
Theory.hs:data TheoryMode = TheoryM
Theory.hs:data TheoryCommand = Debug | Pure | DefaultDepth Int | Load TheoryFile Bool

HashSetDB.hs:newtype Set t = Set {contents :: S.Set t} 
HashSetDB.hs:newtype Project t1 t2 = Project (t1 -> t2)
HashSetDB.hs:newtype Select t = Select (t -> Bool)
ListDB.hs:newtype Set t = Set {contents :: [t]} 
ListDB.hs:newtype Project t1 t2 = Project (t1 -> t2)
ListDB.hs:newtype Select t = Select (t -> Bool)
SetDB.hs:newtype Set t = Set {contents :: S.Set t} 
SetDB.hs:newtype Project t1 t2 = Project (t1 -> t2)
SetDB.hs:newtype Select t = Select (t -> Bool)
Term.hs:newtype Variable = Variable Sym -- Variables
Term.hs:newtype Constant = Constant Sym -- Constants
Term.hs:newtype Element  = Element Int  -- Elements of the domain

Chase.Data.hs:type PullM h a = (PossibleFacts h) => 
Chase.Data.hs:type PushM h it a = (PossibleFacts h, SATIterator it) => 
Chase.Data.hs:{-| ChaseImpl specifies the interface between types that implement a 
Chase.Data.hs:type ChaseM h s a = forall r t it . (ChaseImpl h s r)  => 
Common.Basic.hs:type Id  = Int
Common.Basic.hs:type Sym = String
Config.hs:type ConfigMonad  = State Config
Config.hs:type ConfigMonadT = StateT Config
Counter.hs:type Counter  = State.State Int
Counter.hs:type CounterT = State.StateT Int
Data.hs:type SkolemDepth    = (FnSym, Int)
Data.hs:type SkolemDepthMap = Map.Map FnSym Int
Explain.hs:type ExplainIn = (Theory, ChaseState, Model)
Explain.hs:type ExplainOut = (Theory, ChaseState, Model)
Explore.hs:type ExploreIn = (Config, Theory, ModelSpace, Maybe ModelCoordinate)
Explore.hs:type ExploreOut = (Theory, ModelSpace, Maybe ModelCoordinate)
FirstOrder.hs:type RelSym = Sym
Geometric.hs:type RelSym = Sym
Geometric.hs:type Theory = [Sequent]
Lang.hs:type Attribute  = Variable
Lang.hs:type Column     = Int
Lang.hs:type Header = Map.Map Attribute Column
Lang.hs:type Tup       = Vect.Vector Element
Lang.hs:type Tuple     = TupleD ()
Lang.hs:type TuplePair = TupleD Tup
Lang.hs:type TupleSub  = TupleD ExistsSub
Lang.hs:type TableD a = DB.Set (TupleD a)
Lang.hs:type Table    = TableD ()
Lang.hs:type TablePair = TableD Tup
Lang.hs:type TableSub  = TableD ExistsSub
Lang.hs:type Database = Map.Map TableRef Table
ListDB.hs:newtype Set t = Set {contents :: [t]} 
ListDB.hs:newtype Project t1 t2 = Project (t1 -> t2)
ListDB.hs:newtype Select t = Select (t -> Bool)
PossibleFacts.hs:type ChaseSequentType       = RelSequent
PossibleFacts.hs:type ChasePossibleFactsType = RelPossibleFacts
Provenance.hs:type ElementProvs = ( Map.Map Element SkolemTerm
Provenance.hs:type ObservationProvs = Map.Map Observation Blame 
Provenance.hs:type BlameSequentMap  = Map.Map Blame ObservationSequent
SAT.Impl.hs:type SATIteratorState = State.State SATIteratorType
SMTLib2.hs:type SATIteratorType = SMTContainer
SMTLib2.hs:type SMTElement = String
SMTLib2.hs:type SMTTerm    = String
SMTLib2.hs:type SMTAtom    = String
SMTLib2.hs:type SMTIncomplete = String
SMTLib2.hs:type SatDictionary = Map.Map String Result
SMTLib2.hs:type SBool = SMTExpr Bool
SMTLib2.hs:type SElement = SMTExpr Integer
SMTLib2.hs:type SDomain = Map.Map SMTElement SElement
SMTLib2.hs:type STerms  = Map.Map SMTTerm SElement
SMTLib2.hs:type SAtoms  = Map.Map SMTAtom SBool
SMTLib2.hs:type SIncomplete = Map.Map SMTIncomplete SBool
SMTLib2.hs:type ContainerMonad = State.StateT SMTContainer IO
SMTLib2.hs:type SMTM = SMT' ContainerMonad
Surface.hs:type ChaseState = (ChasePossibleFactsType, ProvInfo, SATIteratorType, Int)
Surface.hs:type ModelSpace = Map.Map ModelCoordinate (ChaseState, Model)
Surface.hs:type Error = String
Surface.hs:type QBlame = Either Error (Blame, Sequent)
Term.hs:type FnSym  = String -- Function Symbols
Term.hs:type SkolemTerm = Term
Term.hs:type Sub = Map.Map Variable Term
Term.hs:type ConsSub = Map.Map Constant Term
Term.hs:type ExistsSub = Map.Map FnSym Term
Theory.hs:type TheoryIn = (Config, Maybe Theory, ModelSpace, Maybe ModelCoordinate)
Theory.hs:type TheoryOut = (Config, Maybe Theory, ModelSpace, Maybe ModelCoordinate)
Theory.hs:type TheoryFile = String
